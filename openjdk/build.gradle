apply plugin: "com.google.osdetector"

description = 'Conscrypt: OpenJdk'

ext {
    jniSourceDir = "$rootDir/common/src/jni"
    jniLibPrefix = "conscrypt_openjdk_jni-${osdetector.os}"

    assert file("$jniSourceDir").exists()
}

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

sourceSets.main {
    java {
        srcDirs = [
                "${rootDir}/common/src/main/java",
                "src/main/java"
        ]
    }
}

dependencies {
    compile project(':conscrypt-constants')

    testCompile libraries.bouncycastle_provider,
                libraries.bouncycastle_apis,
                libraries.junit,
                libraries.mockito
}

// Set the platform-specific classifier on the artifact.
jar {
    classifier = osdetector.classifier
}

model {
    platforms {
        x86 {
            architecture "x86"
        }
        x86_64 {
            architecture "x86_64"
        }
    }

    components {
        // Builds the JNI library.
        "$jniLibPrefix"(NativeLibrarySpec) {
            if (build32Bit) { targetPlatform "x86" }
            if (build64Bit) { targetPlatform "x86_64" }

            sources {
                cpp {
                    source {
                        srcDirs = [
                                "$jniSourceDir/unbundled/cpp",
                                "$jniSourceDir/main/cpp"
                        ]
                    }
                }
            }

            binaries {
                // Build the JNI lib as a shared library.
                withType (SharedLibraryBinarySpec) {
                    cppCompiler.define "CONSCRYPT_OPENJDK"

                    // Set up 32-bit vs 64-bit build
                    def libPaths
                    if (targetPlatform.getArchitecture().getName() == "x86") {
                        libPaths = ["$boringssl32BuildDir/ssl",
                            "$boringssl32BuildDir/crypto"]
                    } else if (targetPlatform.getArchitecture().getName() == "x86-64") {
                        libPaths = ["$boringssl64BuildDir/ssl",
                            "$boringssl64BuildDir/crypto"]
                    } else {
                        throw new GradleException("Unknown architecture: " +
                                targetPlatform.getArchitecture().getName())
                    }

                    if (toolChain in Clang || toolChain in Gcc) {
                        cppCompiler.args "-Wall",
                                "-fPIC",
                                "-O2",
                                "-std=c++11",
                                "-I$jniSourceDir/main/include",
                                "-I$jniSourceDir/unbundled/include",
                                "-I$boringsslIncludeDir",
                                "-I$jdkIncludeDir",
                                "-I$jdkIncludeDir/linux",
                                "-I$jdkIncludeDir/darwin",
                                "-I$jdkIncludeDir/win32"

                        // Static link to BoringSSL
                        libPaths.each { linker.args.add("-L" + it) }
                        linker.args "-O2",
                                "-fvisibility=hidden",
                                "-lstdc++",
                                "-lssl",
                                "-lcrypto"
                    } else if (toolChain in VisualCpp) {
                        cppCompiler.define "DLL_EXPORT"
                        cppCompiler.define "WIN32_LEAN_AND_MEAN"
                        cppCompiler.define "WIN64"
                        cppCompiler.define "_WINDOWS"
                        cppCompiler.define "UNICODE"
                        cppCompiler.define "_UNICODE"
                        cppCompiler.define "NDEBUG"

                        cppCompiler.args "/nologo",
                                "/MT",
                                "/WX-",
                                "/Wall",
                                "/O2",
                                "/Oi",
                                "/Ot",
                                "/GL",
                                "/GS",
                                "/Gy",
                                "/fp:precise",
                                "-wd4548", // Expression before comma has no effect
                                "-wd4625", // Copy constructor was implicitly defined as deleted
                                "-wd4626", // Assignment operator was implicitly defined as deleted
                                "-wd4820", // Extra padding added to struct
                                "-wd4946", // reinterpret_cast used between related classes:
                                "-wd4996", // Thread safety for strerror
                                "-wd5027", // Move assignment operator was implicitly defined as deleted
                                "-I$jniSourceDir/main/include",
                                "-I$jniSourceDir/unbundled/include",
                                "-I$boringsslIncludeDir",
                                "-I$jdkIncludeDir",
                                "-I$jdkIncludeDir/win32"

                        // Static link to BoringSSL
                        libPaths.each { linker.args.add("/LIBPATH:" + it) }
                        linker.args "-WX",
                                "ws2_32.lib",
                                "advapi32.lib",
                                "ssl.lib",
                                "crypto.lib"
                    }
                }

                // Never build a static library.
                withType(StaticLibraryBinarySpec) {
                    buildable = false
                }
            }
        }
    }

    tasks {
        $.binaries.withType(SharedLibraryBinarySpec).each {
            def archName = it.targetPlatform.architecture.name.replaceAll('-', '_')
            def source = it.sharedLibraryFile

            // Copies the native library to a resource location that will be included in the jar.
            task "copyNativeLib${archName}"(type: Copy) {
                from source
                rename '(.+)(\\.[^\\.]+)', "\$1-$archName\$2"
                // This location will automatically be included in the jar.
                into "build/resources/main/META-INF/native"
            }

            // Make sure we build and copy the native library to the output directory.
            compileJava.dependsOn "copyNativeLib${archName}"
        }
    }
}

def getFileExtension(File f) {
    String name = f.getName()
    return new String(name.substring(name.lastIndexOf('.')))
}
