description = 'Conscrypt: OpenJdk'

ext {
    jniSourceDir = "$rootDir/common/src/jni"
    assert file("$jniSourceDir").exists()

    // Build the list of classifiers that will be used in the build.
    arch32Name = 'x86'
    arch64Name = 'x86_64'
    jvmArgs32 = '-d32'
    jvmArgs64 = '-d64'
    // Allow the java executable to be specified via env/property for each architecture.
    javaExecutable32 = properties['javaExecutable32'] ?: System.env.CONSCRYPT_JAVA_EXECUTABLE_32
    javaExecutable64 = properties['javaExecutable64'] ?: System.env.CONSCRYPT_JAVA_EXECUTABLE_64
    nativeClassifiers = []
    if (build32Bit) {
        nativeClassifiers += classifierFor(osName, arch32Name)
    }
    if (build64Bit) {
        nativeClassifiers += classifierFor(osName, arch64Name)
    }
}

sourceSets {
    main {
        java {
            srcDirs += "${rootDir}/common/src/main/java"
            srcDirs += project(':conscrypt-constants').sourceSets.main.java.srcDirs
        }
    }
}

// Append the BoringSSL-Version to the manifest.
jar.manifest {
    attributes 'BoringSSL-Version' : boringSslVersion
}

// Since we're not taking a direct dependency on the constants module, we need to add an
// explicit task dependency to make sure the code is generated.
compileJava.dependsOn project(':conscrypt-constants').build

dependencies {
    testCompile project(':conscrypt-testing'),
                libraries.junit,
                libraries.mockito
}

/**
 * Create Jar and Test tasks for each native classifier.
 */
nativeClassifiers.each { nativeClassifier ->
    // Normalize the classifier so that it may be used in task names. We'll also use
    // the normalized name for the resource directory.
    def normalizedClassifier = normalizeClassifier("${nativeClassifier}")
    def nativeFiles = files("${buildDir}/${normalizedClassifier}/resources/main")

    // Create a configuration for the native JAR.
    configurations.create("$normalizedClassifier")
    def sources = sourceSets.create("$normalizedClassifier")
    sources.resources {
        srcDirs += nativeFiles
    }

    // Create a JAR for this configuration and add it to the output archives.
    def jarTaskName = "create${normalizedClassifier}Jar"
    task "$jarTaskName"(type: Jar) {
        dependsOn classes
        dependsOn compileJava
        from sourceSets.main.output + nativeFiles
        manifest = jar.manifest
        classifier = nativeClassifier
    }
    // Add it to the 'archives' configuration so that the artifact will be automatically built and
    // installed/deployed.
    artifacts.add('archives', tasks["$jarTaskName"])
    // Also add the artifact to its own configuration so that it can be referenced from other projects.
    artifacts.add("$normalizedClassifier", tasks["$jarTaskName"])

    // Create the test task and have it auto run whenever the test task runs.
    def testTaskName = "${normalizedClassifier}Test"
    task "$testTaskName"(type: Test) {
        testClassesDir = test.testClassesDir
        classpath = test.classpath + nativeFiles
        if (nativeClassifier.endsWith(arch32Name)) {
            jvmArgs jvmArgs32
            if (javaExecutable32 != null) {
                executable = javaExecutable32
            }
        } else {
            jvmArgs jvmArgs64
            if (javaExecutable64 != null) {
                executable = javaExecutable64
            }
        }
    }
    test.dependsOn "$testTaskName"
}

// Exclude all test classes from the default test suite.
// We will test each available native artifact separately (see nativeClassifiers).
test.exclude("**")

model {
    platforms {
        x86 {
            architecture arch32Name
        }
        x86_64 {
            architecture arch64Name
        }
    }

    buildTypes {
        release
    }

    components {
        // Builds the JNI library.
        conscrypt_openjdk_jni(NativeLibrarySpec) {
            if (build32Bit) { targetPlatform arch32Name }
            if (build64Bit) { targetPlatform arch64Name }

            sources {
                cpp {
                    source {
                        srcDirs "$jniSourceDir/main/cpp"
                        include "**/*.cpp"
                    }
                }
            }

            binaries {
                // Build the JNI lib as a shared library.
                withType (SharedLibraryBinarySpec) {
                    cppCompiler.define "CONSCRYPT_OPENJDK"

                    // Set up 32-bit vs 64-bit build
                    def libPath
                    if (targetPlatform.getArchitecture().getName() == "x86") {
                        libPath = "$boringssl32BuildDir"
                    } else if (targetPlatform.getArchitecture().getName() == "x86-64") {
                        libPath = "$boringssl64BuildDir"
                    } else {
                        throw new GradleException("Unknown architecture: " +
                                targetPlatform.getArchitecture().name)
                    }

                    if (toolChain in Clang || toolChain in Gcc) {
                        cppCompiler.args "-Wall",
                                "-fPIC",
                                "-O2",
                                "-std=c++11",
                                "-I$jniSourceDir/main/include",
                                "-I$jniSourceDir/unbundled/include",
                                "-I$boringsslIncludeDir",
                                "-I$jdkIncludeDir",
                                "-I$jdkIncludeDir/linux",
                                "-I$jdkIncludeDir/darwin",
                                "-I$jdkIncludeDir/win32"

                        // Static link to BoringSSL
                        linker.args "-O2",
                                "-fvisibility=hidden",
                                "-lstdc++",
                                libPath + "/ssl/libssl.a",
                                libPath + "/crypto/libcrypto.a"
                    } else if (toolChain in VisualCpp) {
                        cppCompiler.define "DLL_EXPORT"
                        cppCompiler.define "WIN32_LEAN_AND_MEAN"
                        cppCompiler.define "WIN64"
                        cppCompiler.define "_WINDOWS"
                        cppCompiler.define "UNICODE"
                        cppCompiler.define "_UNICODE"
                        cppCompiler.define "NDEBUG"

                        cppCompiler.args "/nologo",
                                "/MT",
                                "/WX-",
                                "/Wall",
                                "/O2",
                                "/Oi",
                                "/Ot",
                                "/GL",
                                "/GS",
                                "/Gy",
                                "/fp:precise",
                                "-wd4514", // Unreferenced inline function removed
                                "-wd4548", // Expression before comma has no effect
                                "-wd4625", // Copy constructor was implicitly defined as deleted
                                "-wd4626", // Assignment operator was implicitly defined as deleted
                                "-wd4710", // function not inlined
                                "-wd4711", // function inlined
                                "-wd4820", // Extra padding added to struct
                                "-wd4946", // reinterpret_cast used between related classes:
                                "-wd4996", // Thread safety for strerror
                                "-wd5027", // Move assignment operator was implicitly defined as deleted
                                "-I$jniSourceDir/main/include",
                                "-I$jniSourceDir/unbundled/include",
                                "-I$boringsslIncludeDir",
                                "-I$jdkIncludeDir",
                                "-I$jdkIncludeDir/win32"

                        // Static link to BoringSSL
                        linker.args "-WX",
                                "ws2_32.lib",
                                "advapi32.lib",
                                libPath + "\\ssl\\ssl.lib",
                                libPath + "\\crypto\\crypto.lib"
                    }
                }

                // Never build a static library.
                withType(StaticLibraryBinarySpec) {
                    buildable = false
                }
            }
        }
    }

    tasks { t ->
        $.binaries.withType(SharedLibraryBinarySpec).each { binary ->
            // Build the native artifact classifier from the OS and architecture.
            def archName = binary.targetPlatform.architecture.name.replaceAll('-', '_')
            def classifier = classifierFor(osName, archName)
            def normalizedClassifier = normalizeClassifier("$classifier")
            def source = binary.sharedLibraryFile

            // Copies the native library to a resource location that will be included in the jar.
            task "copyNativeLib${normalizedClassifier}"(type: Copy) {
                dependsOn "conscrypt_openjdk_jniSharedLibrary"
                from source
                // Rename the artifact to include the generated classifier
                rename '(.+)(\\.[^\\.]+)', "\$1-$classifier\$2"
                // This location will automatically be included in the jar.
                into "${buildDir}/${normalizedClassifier}/resources/main/META-INF/native"
            }

            // Make sure we build and copy the native library to the output directory.
            compileJava.dependsOn "copyNativeLib${normalizedClassifier}"

            // Now define a task to strip the release binary (linux only)
            def stripTask = binary.tasks.taskName("strip")
            t.create(stripTask) {
                dependsOn binary.tasks.link
                doFirst {
                    if (osName == 'linux') {
                        ["strip", binary.tasks.link.outputFile].execute().waitForOrKill(1000)
                    }
                }
            }
            binary.tasks.build.dependsOn stripTask
        }
    }
}

static classifierFor(osName, archName) {
    return "${osName}-${archName}"
}

static normalizeClassifier(classifier) {
    return classifier.replaceAll("-", "_")
}
